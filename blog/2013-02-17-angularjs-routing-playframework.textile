---
title: "AngularJS HTML5 routing on PlayFramework"
authors: [pauldijou]
layout: post
summary: 0
tags: [en, fr, angular, play, html5]
---
<ul class="nav nav-tabs">
<li class="active"><a href="#2013-02-17-angularjs-routing-playframework-en" data-toggle="tab">English version</a></li>
<li><a href="#2013-02-17-angularjs-routing-playframework-fr" data-toggle="tab">Version Fran√ßaise</a></li>
</ul>

<div class="tab-content">
<div class="tab-pane active" id="2013-02-17-angularjs-routing-playframework-en">

h3. The problem

AngularJS provides a nice <code>$location</code> service which allows you to deal with routing and url inside your application. It supports both a fallback mode using hashbang and a real HTML5 routing using the new "History API":http://www.whatwg.org/specs/web-apps/current-work/multipage/history.html. Since we love bleeding edge technologies, that's obvious we want to use the History API if possible. Lucky us, it appears it's quite easy to do so with a Play Framework application. Let's see how to do that.

The full code of the demo is available here: "https://github.com/blogsamples/angularjs-play21-html5-routing":https://github.com/blogsamples/angularjs-play21-html5-routing

h3. Simple configuration

Let's keep things simple. Creating a new Play Framework application with <code>play new</code>. We will use a Scala application in this article, but it should as easy with a Java one. Then add AngularJS using CDN (see "https://github.com/blogsamples/angularjs-play21-html5-routing/blob/master/app/views/main.scala.html#L19":https://github.com/blogsamples/angularjs-play21-html5-routing/blob/master/app/views/main.scala.html#L19). Then we will create an Angular module for our app and enable the HTML5 routing mode which is disable by default.

bc(prettyprint linenums).. var app = angular.module("app", ["ngResource"])
  .config(["$routeProvider", function($routeProvider) {
      return $routeProvider.when("/", {
        templateUrl: "/views/index",
        controller: "AppCtrl"
      }).otherwise({
        redirectTo: "/"
      });
    }
  ])
  .config(["$locationProvider", function($locationProvider) {
      return $locationProvider.html5Mode(true).hashPrefix("!");
    }
  ]);

Nice. Now we will make some modification to the default views generated by Play. We want a single-page application, which means our root url must map to a main page which will contains all resource dependencies and includes the <code>ng-view</code> of AngularJS. I've done that by editing the "main.scala.html" file as you can see here: "https://github.com/blogsamples/angularjs-play21-html5-routing/blob/master/app/views/main.scala.html":https://github.com/blogsamples/angularjs-play21-html5-routing/blob/master/app/views/main.scala.html and add a new Play route:

bc(prettyprint linenums).. GET     /                           controllers.Application.main(any = "none")

p. And a new <code>Action</code> in my Application controller:

bc(prettyprint linenums).. def main(any: String) = Action {
  Ok(views.html.main())
}

p. Wait. Why is there a String param for the main method? And why do we pass a default <code>any = "none"</code> value? It seems a bit useless... Fair enough, I will explain it later on the article, don't mind it for now. So, we have our main page. Let's add some content for the landing page. As we have specified in the AngularJS routing, our root url, which is defined with <code>$routeProvider.when("/", ...)</code> is pointing to <code>/views/index</code>. So we need a Play route for that... but before, let's talk about all those routes.

h3. Routes, routes, routes...

As we advance in our coding, we can see that the term "route" is used in different contexts. It's important to fully understand them all. Play routes, which are defined in the <code>conf/routes</code> file, are the core of your application. It's those routes which will answer to the HTTP requests, serving either HTML, JSON, or whatever. But you, as the developer, will be the only one to know about them. Users of your application will only use and see AngularJS routes, which are defined in your main module using the <code>$routeProvider</code>.

The idea is that when a user land on your site, it should use AngularJS routing which will then use Play routes to load the template (= the content) of the page. So why not using the exact same url for both the AngularJS route and the templateUrl route? Well, in the case of the root, it's obvious: the Play "/" route is already required for our main page. Ok. But in a more general case, could we do:

bc(prettyprint linenums).. $routeProvider.when("/page", {
  templateUrl: "/page",
  controller: "PageCtrl"
})

p. Nope, you can't. Well, that's a small lie... you could do that, and it would work if your user *always* open your main page first. If he does that, then all AngularJS routing is loaded, and when the user will go to "/page" url, it will be catch by AngularJS which will ask for the "/page" on Play routes which will give him the content of the page. So what's the problem? If you user *directly* land on the "/page" url, because he arrived for the first time on your application after having clicked on a link somewhere which was pointing at "/page", then the Play route will be directly called since there is no AngularJS routing initialized at all... And that's bad, right? The user would have the raw content of the page without any JavaScript or CSS from the main page. It's a fail.

In order to prevent that, I have chosen to use some conventions. There is nothing official, you can use your own, the only thing to keep in mind is that AngularJS routes and Play routes should *never* be equals. My solution to do that is to prefix all Play routes serving HTML with a "/views/" prefix, all Play routes serving JSON with a "/api/" prefix and, as it is by default, all Play routes serving resources with a "/assets/" prefix. Meaning I can now use all routes I want inside AngularJS routing but never starts them with one of those prefix.

Of course, it will just modify the problem without solving it. Now, if a user land directly on "/page", he will have a huge orange Play error telling him that the route doesn't exist. As before, AngularJS routing isn't loaded, so it's Play routing which try to handle that and, since there is no longer any "/page" route in Play, it crash.

So what's the point of having different routes? The next trick is to redirect all unknow routes to our main page. By doing so, if the user land on "/page", Play will say %(talk red)"I don't know that route, go to the main page"%, so the user will indeed go to your main page, but then, all AngularJS routing will be loaded and super awesome AngularJS will say %(talk blue)"Hey, I do know that route, and I need the /views/page template"%, and then Play will respond %(talk red)"Oh yeah, I can serve you /views/page, here is the HTML to display"%, and your user will see the correct "/page1" content, even if he lands directly on it.

Another question? Why didn't we use this trick before and then have the same routes for both AngularJS and Play? Because it's important that the trick apply only to unknow routes. We cannot redirect to the main page an existing Play route because it needs to serve its own content. So by using different routes, we can intercept AngularJS routes inside Play as "unknown routes" and redirect them to the main page so AngularJS can handle them. I hope I'm clear enough here, that might be the hardest part of the article. In order to achieve that, we just need to put a Play route at the end of the route file which intercept all routes and redirect them to the main page:

bc(prettyprint linenums).. GET     /*any                       controllers.Application.main(any)

p. And now you should understand why we had a <code>any: String</code> for our main page at the beginning.

h3. First pages

Enough with all the theory, let's do two concrete pages: creating "page1.scala.html" and "page2.scala.html" files with basic content (see source code, I'm using a template to stay DRY about the title and the menu but that's not important), add then as Play routes (with a "/views/" as stated before) and also add them inside our controller:

bc(prettyprint linenums).. @()

@template() {
  <h2>Page1</h2>
}

bc(prettyprint linenums).. GET     /views/page1                controllers.Application.page1

bc(prettyprint linenums).. def page1 = Action {
  Ok(views.html.page1())
}

p. And then add the AngularJS routing:

bc(prettyprint linenums).. .when("/page1", {
  templateUrl: "/views/page1"
})

p. That's it. We can now create a link, using a <code>a</code> tag, to point to the url "/page1" and AngularJS will do the rest, loading the "/views/page1" template using Play route which will return the HTML code generated from our Scala template. Nice isn't it? The url is correct: http://localhost:9000/page1, you can use the back button to return to the index page, no ugly hashbang, but all in Ajax with a single-page application.

h3. Handling url parameters

So, we have our url working by using the History API thanks to the HTML5 mode of the AngularJS $routeProvider. But that's only for raw url. What if we want to have dynamic parameters inside them? Just like REST, having url as "/colors/1" and "/colors/2" if we deal with colors (yeah, why not?). Do you think that's easy? Well, you could, after all, both AngularJS and Play know how to handle parameters in their url. We could do something like:

bc(prettyprint linenums).. .when("/colors/:id", {
  templateUrl: "/views/color/:id",
  controller: "ColorCtrl"
})

bc(prettyprint linenums).. GET     /views/color/:id             controllers.Application.color(id: String)

p. Nope, we can't. Why? Because the "templateUrl" cannot handle url parameters. It's just a template. And of course, using <code>templateUrl: "/views/color"</code> will not pass any "id" parameter to the Play route. Damn...

That's not a problem in fact. Just keep to the AngularJS way of doing things: it's not Play who should handle the data any longuer, it's AngularJS who rules the world now, so you don't need any params in your Scala code, just trust AngularJS. Ok, but we need a way to load the correct color depending on the id in the url right? Sure thing. It's the role of AngularJS controller to that. That's why there is a "ColorCtrl" along with our template, and guess what, the AngularJS controller know about the url params. Here is the code of the controller:

bc(prettyprint linenums).. app.controller("ColorCtrl", ["$scope", "$routeParams", function($scope, $routeParams) {
  // Thanks to scope inheritance, we can access the "db" from the AppCtrl scope
  $scope.color = $scope.db[$routeParams.id];
  if (!$scope.color) {
    $scope.msg = "There is no color for id "+$routeParams.id;
  } else {
    $scope.msg = undefined;
  }
}])

p. And just for fun, I've defined the fake database in the "AppCtrl":

bc(prettyprint linenums).. app.controller("AppCtrl", ["$scope", function($scope) {
  $scope.db = {
    1: {
      name: "black",
      hex: "000000"
    },
    2: {
      name: "white",
      hex: "FFFFFF"
    }
  };
}]);

p. So as we can see, using the <code>$routeParams</code> service, we can retrieve the url params and then load the correct color in the <code>$scope</code>. At the end, it's just a matter of displaying that color in our view using AngularJS data-binding:

bc(prettyprint linenums).. @()

@template() {
  <div data-ng-show="msg">
    <h2>{{msg}}</h2>
  </div>

  <div data-ng-hide="msg">
    <h2>Color {{color.name}}: # {{color.hex}}</h2>
  </div>
}

p. And that's it! you can now display some data depending of params inside your url (and show an error message in case the data doesn't exist). Cool isn't it?

h3. Want more?

Oh God, you are still reading? You should already be able to do anything you need. But if you want, we can dive in a more complex example, using AngularJS <code>$resource</code> service and serve JSON from Play like a REST API would do. Sounds good for you? Ok, let's do that. First, we will create a "Users" controller and it will have two methods: "all()" and "find(id: String)" which will return an Array of Json and a Json object representing our list of users and one particular user based on its id. I will not use a real database, but something like MongoDB would fit really good in there. Here is the code:

bc(prettyprint linenums).. package controllers

import play.api._
import play.api.mvc._
import play.api.libs.json._

object Users extends Controller {
  val db = Json.arr(
    Json.obj( "id" -> "1", "name" -> "John" ),
    Json.obj( "id" -> "2", "name" -> "Suzanne" )
  )

  def all() = Action {
    Ok(db)
  }

  def find(id: String) = Action {
    Ok(db.value.filter(v => (v \ "id").as[JsString].value == id).headOption.getOrElse(new JsUndefined("")))
  }
}

p. If you don't fully understand it, you can check the PlayFramework documentation about handling Json ("http://www.playframework.com/documentation/2.1.0/ScalaJsonRequests":http://www.playframework.com/documentation/2.1.0/ScalaJsonRequests). I am using the new Json API from Play 2.1 ("http://www.playframework.com/documentation/api/2.1.0/scala/index.html#play.api.libs.json.package":http://www.playframework.com/documentation/api/2.1.0/scala/index.html#play.api.libs.json.package). Next we need our "UserCtrl" which will use the <code>$resource</code> service to retrieve the data:

bc(prettyprint linenums).. app.controller("UserCtrl", ["$scope", "$routeParams", "$resource", "apiUrl", function($scope, $routeParams, $resource, apiUrl) {
  var Users = $resource(apiUrl + "/users/:id", {id:"@id"});

  if($routeParams.id) {
    $scope.user = Users.get({id: $routeParams.id}, function() {
      if (!$scope.user.id) {
        $scope.msg = "There is no user for id "+$routeParams.id;
      } else {
        $scope.msg = undefined;
      }
    });
  } else {
    $scope.users = Users.query();
  }
}])

p. To learn more about AngularJS $resource definition, see: "http://docs.angularjs.org/api/ngResource.$resource":http://docs.angularjs.org/api/ngResource.$resource. What is that "apiUrl" by the way? It's a constant I've defined in my AngularJS app:

bc(prettyprint linenums).. var app = angular.module("app", ["ngResource"])
  .constant("apiUrl", "http://localhost:9000\:9000/api")

div(alert alert-info). *Pro tip* Why is there the 9000 port twice? That's because if we had written <code>http://localhost:9000/api</code>, AngularJS syntax would have analyzed that as a url with a dynamic parameter named "9000" because it's placed right after a <code>:</code> character. So we need that strange syntax to tell AngularJS that this is not a parameter but a real value in our url.

Next, we are creating our resource by extending this apiUrl with our routing "/users/:id". This time, ":id" is a real parameter. We can now use "get" and "query" methods on the resource, passing or not a value to the id, in order to retrieve our Json code and assign it to the <code>$scope</code>. We will need two Scala views: one for the list and one for the detail of course.

bc(prettyprint linenums).. @()

@template() {
  <h2>Users</h2>

  <ul>
    <li data-ng-repeat="u in users">
      <a data-ng-href="/users/{{u.id}}">User# {{u.id}}: {{u.name}}</a>
    </li>
  </ul>
}


bc(prettyprint linenums).. @()

@template() {
  <div data-ng-show="msg">
    <h2>{{msg}}</h2>
  </div>

  <div data-ng-hide="msg">
    <h2>User# {{user.id}} {{user.name}}</h2>
  </div>
}

p. And that's it. We now have a list of users and links to each user detail, and all that data is fetch from a REST API using Json.

div(alert alert-info). *Pro tip* By the way, since our Play routes doesn't clash with AngularJS routes, you can load them directly in your browser. It will works because the Play route handling the redirection to the main page is at the end of the route file, so any real Play route will be loaded before the redirection. If you have the demo running, check "http://localhost:9000/api/users":http://localhost:9000/api/users and "http://localhost:9000/api/users/1":http://localhost:9000/api/users/1 to see your REST API working nicely.

h3. Conclusion

I hope this article will help you bootstrap your next awesome application using awesome tools like AngularJS and PlayFramework. Your next step (if that's not already the case) would be to learn more about the new PlayFramework Json API so you can have typesafe Json (if I can say so). You would also probably need to plug a database on it. One choice could be a "MongoDB":http://www.mongodb.org/ database since it can store raw Json, and interact with it using a nice driver like "ReactiveMongo":http://reactivemongo.org/ if you want to go all the way down to asynchronous application.

It's up to you!

</div>
<div class="tab-pane" id="2013-02-17-angularjs-routing-playframework-fr">

h3. Le probl√®me

AngularJS fournit un service bien utile du nom de <code>$location</code> qui permet de g√©rer les urls et le routing de votre application. Il supporte √† la fois un mode par d√©fault utilisant un hashbang et un mode r√©ellement HTML5 utilisant la nouvelle "History API":http://www.whatwg.org/specs/web-apps/current-work/multipage/history.html. Comme nous sommes partisants des technologies √† la pointe, il est √©vident qu'il nous faut utiliser l'API History. Et comme nous sommes chanceux, c'est relativement simple de faire cela avec PlayFramework.

Le code source de la d√©mo est disponible ici : "https://github.com/blogsamples/angularjs-play21-html5-routing":https://github.com/blogsamples/angularjs-play21-html5-routing

h3. Simple configuration

Commen√ßons par les bases en cr√©ant une nouvelle application Play Framework via la commande <code>play new</code>. Nous allons utiliser la version Scala dans cet article mais c'est tout aussi simple en Java. Une fois l'application g√©n√©r√©e, on va pouvoir ajouter AngularJS en utilisant un CDN (voir "https://github.com/blogsamples/angularjs-play21-html5-routing/blob/master/app/views/main.scala.html#L19":https://github.com/blogsamples/angularjs-play21-html5-routing/blob/master/app/views/main.scala.html#L19). Enfin, nous allons cr√©er un module AngularJS pour configurer notre application et activer le routing HTML5 car il est d√©sactiv√© par d√©faut.

bc(prettyprint linenums).. var app = angular.module("app", ["ngResource"])
  .config(["$routeProvider", function($routeProvider) {
      return $routeProvider.when("/", {
        templateUrl: "/views/index",
        controller: "AppCtrl"
      }).otherwise({
        redirectTo: "/"
      });
    }
  ])
  .config(["$locationProvider", function($locationProvider) {
      return $locationProvider.html5Mode(true).hashPrefix("!");
    }
  ]);

Cool. On va maintenant modifier les vues g√©n√©r√©es par Play. Nous voulons r√©aliser une "single-page" application et pour cela, notre url racine doit pointer sur une page principale qui contiendra le chargement de toutes nos ressources et incluera la balise <code>ng-view</code> d'AngularJS. Pour cela, j'ai √©dit√© le fichier "main.scala.html" comme vous pouvez le voir ici : "https://github.com/blogsamples/angularjs-play21-html5-routing/blob/master/app/views/main.scala.html":https://github.com/blogsamples/angularjs-play21-html5-routing/blob/master/app/views/main.scala.html et j'ai ajout√© la route Play suivante :

bc(prettyprint linenums).. GET     /                           controllers.Application.main(any = "none")

p. Ainsi qu'une nouvelle <code>Action</code> dans le controller Application :

bc(prettyprint linenums).. def main(any: String) = Action {
  Ok(views.html.main())
}

p. Attendez... Pourquoi y a-t-il un param√®tre de type String dans la m√©thode main ? Et pourquoi lui passe-t-on in valeur par d√©fault <code>any = "none"</code> ? Cela semble assez inutile... C'est pas faux. J'expliquerai plus tard le pourquoi du comment de ce param√®tre, juste ignorez le pour le moment. Nous avons donc notre page principale. Ajoutons maintenant du contenu √† la page d'accueil, laquelle est d√©finie via <code>$routeProvider.when("/", ...)</code> qui pointe sur <code>/views/index</code>. Nous avons donc besoin d'une route Play pour cela... mais avant, parlons un peu de toutes ces routes.

h3. Routes, routes, routes...

En m√™me temps que notre code s'enrichit, on remarquera que le terme "route" est appliqu√© dans diff√©rents contextes. Il est tr√®s important de bien comprendre cette notion. Les routes Play, qui sont d√©finies dans le fichier<code>conf/routes</code>, sont le socle de votre application. C'est elles qui vont r√©pondre aux requ√™tes HTTP et retourner le code HTML, JSON ou n'importe quoi d'autre. Mais vous, en tant que d√©veloppeur, serez le seul √† les connaitre. Les utilisateurs de votre application, eux, ne verront et n'utiliseront que les routes AngularJS qui sont d√©finies dans votre module via le service <code>$routeProvider</code>.

L'id√©e est que lorsqu'un utilisateur arrive sur votre site, il va utiliser le routing d'AngularJS qui lui-m√™me va utiliser les routes Play pour charger le template (= le contenu) de la page. Dans ce cas, pourquoi ne pas utiliser les m√™mes urls pour √† la fois AngularJS et Play ? Dans le cas de l'url racine, la r√©ponse est √©vidente : la route "/" dans Play est d√©j√† utilis√©e pour servir la page principale. D'accord, mais dans un cas plus g√©n√©ral, est-ce qu'on ne pourrait pas avoir quelque chose de la forme :

bc(prettyprint linenums).. $routeProvider.when("/page", {
  templateUrl: "/page",
  controller: "PageCtrl"
})

p. Et non, on ne peut pas. Enfin, c'est un peu un mensonge... vous pourriez faire cela, et √ßa fonctionnerait si votre utilisateur arrivait *toujours* sur la page principale en premier lieu. En faisant cela, il chargerait tout le routing d'AngularJS et, ensuite, quand il irait sur l'url "/page", AngularJS se chargerait d'appeler la route Play "/page" et afficherait ainsi le bon contenu. Alors quel est le probl√®me ? Si votre utilisateur arrivait *directement* sur l'url "/page", parce qu'il aurait par exemple cliqu√© sur un lien depuis un autre site pointant directement sur "/page" dans votre site, et bien dans ce cas, le routing AngularJS ne serait pas du tout charg√©... Et √ßa c'est mal parce que cela voudrait dire que c'est directement la route Play "/page" qui sera charg√©e, affichant le contenu de la page de mani√®re brute sans aucune ressource JavaScript ou CSS. Gros fail.

Afin d'√©viter cela, j'ai opt√© pour quelques conventions. Il n'y a rien d'officiel bien entendu, vous pouvez utiliser les votres, la seule chose importante √©tant que les routes AngularJS et les routes Play ne doivent *jamais* √™tre √©gales. Ma solution est de pr√©fixer toutes les routes Play qui servent du HTML par "/views/", toutes celles qui servent du JSON par "/api/" et, comme c'est le cas par d√©faut, toutes celles qui servent des ressources par "/assets/". Je peux donc maintenant utiliser toutes les routes que je veux dans AngularJS tant qu'elles ne d√©butent pas par un de ces pr√©fixes.

Bien entendu, cela ne fait que d√©porter le probl√®me. Maintenant, si un utilisateur arrive directement sur "/page", il aura une grosse erreur orange de Play lui disant que la route n'existe pas. C'est exactement la m√™me chose que pr√©c√©demment : comme le routing AngularJS n'est pas encore charg√©, c'est le routing Play qui essaye de s'occuper de la requ√™te mais comme il n'y a plus de route "/page" dans Play, √ßa plante.

Alors quoi ? Ca ne servait √† rien de faire des routes diff√©rentes au final ? Pas de panique, j'ai une autre astuce √† vous proposer ! Il s'agit de rediriger toutes les routes inconnues vers la page principale. Ce faisant, si l'utilisateur arrive directement sur l'url "/page", Play va dire %(talk red)"Hey, je ne connais pas cette route, va sur la page principale"%, et l'utilisateur va donc √™tre redirig√© sur la page principale, et c'est alors que tout le routing AngularJS va √™tre charg√© et notre incroyable AngularJS va pouvoir s'exclamer %(talk blue)"Hey, moi je connais cette route, et d'ailleurs j'ai besoin du template /views/page pour l'afficher"%, ce √† quoi Play va r√©pondre %(talk red)"Ah ouais, je peux te filer /views/page, voici le code HTML √† afficher"%, et votre utilisateur va ainsi afficher le bon contenu pour "/page", et ce m√™me s'il arrive directement sur cette url.

Une autre question ? Pourquoi ne pas avoir utilis√© cette astuce tout √† l'heure et ainsi pouvoir avoir les m√™mes routes pour AngularJS et Play ? Parce qu'il est important que l'astuce ne s'applique qu'aux routes inconnues de Play. En effet, on ne peut pas rediriger une route Play existante vers la page principale puisqu'elle a d√©j√† son propre contenu √† retourner. En utilisant des routes diff√©rentes entre AngularJS et Play, on peut ainsi consid√©rer toutes les routes inconnues dans Play comme √©tant les routes AngularJS et les rediriger vers la page principale pour s'assurer que le routing AngularJS sera √† m√™me de les g√©rer. Pour faire cela, on a juste besoin de rajouter cette route √† la toute fin du ficher de routes de Play :

bc(prettyprint linenums).. GET     /*any                       controllers.Application.main(any)

p. Maintenant, vous devriez comprendre pourquoi nous avions un param√®tre <code>any: String</code> pour notre page principale pr√©c√©demment.

h3. Premi√®res pages

Assez de th√©orie, cr√©ons quelques vraies pages ! Commen√ßons par deux simples pages en cr√©ant les fichiers "page1.scala.html" et "page2.scala.html" avec un contenu minimaliste au possible (voir le code source, j'utilise un template pour rester DRY au niveau du titre et du menu mais c'est pas vraiment important), puis ajoutons les routes Play (avec un prefix "/views/" comme indiqu√© ci-dessus) ainsi que les m√©thodes dans notre controller Application :

bc(prettyprint linenums).. @()

@template() {
  <h2>Page1</h2>
}

bc(prettyprint linenums).. GET     /views/page1                controllers.Application.page1

bc(prettyprint linenums).. def page1 = Action {
  Ok(views.html.page1())
}

p. Et bien sur le routing AngularJS correspondant :

bc(prettyprint linenums).. .when("/page1", {
  templateUrl: "/views/page1"
})

p. C'est tout. On peut maintenant cr√©er des liens avec la balise <code>a</code> pour pointer sur l'url "/page1" et AngularJS se chargera de faire le reste, chargeant le template "/views/page1" via la route Play correspondante qui va retourner le code HTML g√©n√©r√© via notre template Scala. Pas si mal n'est ce pas ? L'url est correct : http://localhost:9000/page1, vous pouvez utiliser le bouton retour de votre navigateur pour revenir √† la page pr√©c√©dente, pas de hashbang tout moche, tout en Ajax dans une application "single-page".

h3. G√©rer des param√®tres dans les urls

Bon. Nous avons nos urls qui fonctionnent en utilisant l'API History gr√¢ce au mode HTML5 du $routeProvider d'AngularJS. C'est d√©j√† pas mal. Mais il ne s'agit que d'urls fixes. Que se passerait-il si nous voulions introduire des param√®tres dynamiques au sein de celles-ci ? Un peu comme faire du REST, avec des urls comme "/colors/1" et "/colors/2" si notre application g√®re des couleurs (oui, pourquoi pas ?). Est-ce que cela va √™tre facile ? On pourrait le penser, apr√®s tout, AngularJS et Play savent tous les deux g√©rer de tels param√®tres dans leurs urls. On pourrait tenter un truc comme :

bc(prettyprint linenums).. .when("/colors/:id", {
  templateUrl: "/views/color/:id",
  controller: "ColorCtrl"
})

bc(prettyprint linenums).. GET     /views/color/:id             controllers.Application.color(id: String)

p. Ou pas... En pratique, le "templateUrl" d'AngularJS ne g√®re pas les param√®tres dans son url. Et bien entendu, utiliser <code>templateUrl: "/views/color"</code> ne va passer aucun param√®tre √† notre route Play. Pas de bol...

En r√©alit√©, ce n'est pas vraiment un probl√®me. Il faut juste revenir aux fondamentaux d'AngularJS : ce n'est pas √† Play de g√©rer les donn√©es dans ses Action, c'est AngularJS qui domine le monde (enfin, l'application du moins), et vous n'avez donc pas besoin de param√®tres dans votre code Scala, faites juste confiance √† AngularJS. Apr√®s, on est d'accord qu'il va nous falloir un moyen de charger les bonnes donn√©es selon la valeur de l'url. Et c'est d'ailleurs le role des controllers AngularJS. C'est pour cela qu'il existe un "ColorCtrl" juste √† c√¥t√© de notre templateUrl. Et devinez quoi, les controllers AngularJS savent r√©cup√©rer les param√®tres au sein de vos urls. Voici comment faire :

bc(prettyprint linenums).. app.controller("ColorCtrl", ["$scope", "$routeParams", function($scope, $routeParams) {
  // Thanks to scope inheritance, we can access the "db" from the AppCtrl scope
  $scope.color = $scope.db[$routeParams.id];
  if (!$scope.color) {
    $scope.msg = "There is no color for id "+$routeParams.id;
  } else {
    $scope.msg = undefined;
  }
}])

p. Et juste pour le fun, j'ai d√©fini la fausse base de donn√©es dans le controller "AppCtrl" :

bc(prettyprint linenums).. app.controller("AppCtrl", ["$scope", function($scope) {
  $scope.db = {
    1: {
      name: "black",
      hex: "000000"
    },
    2: {
      name: "white",
      hex: "FFFFFF"
    }
  };
}]);

p. Comme on peut le voir, en utilisant le service <code>$routeParams</code>, on peut r√©cup√©rer le param√®tre de l'url et charger la bonne couleur dans le <code>$scope</code>. Au final, il ne reste plus qu'√† afficher cela dans notre vue en utilisant le data-binding d'AngularJS :

bc(prettyprint linenums).. @()

@template() {
  <div data-ng-show="msg">
    <h2>{{msg}}</h2>
  </div>

  <div data-ng-hide="msg">
    <h2>Color {{color.name}}: # {{color.hex}}</h2>
  </div>
}

p. Et voil√† ! Vous pouvez maintenant afficher diff√©rentes donn√©es selon les param√®tres dans vos urls (et au passage √©galement un message d'erreur dans le cas o√π l'url ne correspond √† aucune donn√©e). Pas si mal n'est ce pas ?

h3. Vous en voulez plus ?

Encore en train de lire ? Vous devriez d√©j√† √™tre en mesure de faire ce dont vous avez besoin. Mais si vous le souhaitez, on peut aborder un exemple un peu plus complexe qui utiliserait le service <code>$resource</code> d'AngularJS tout en servant du JSON depuis Play comme le ferait une API REST. Ca vous tente ? Ok, faisons cela. En premier lieu, on va cr√©er un nouveau controller "Users" qui aura deux m√©thodes "all()" et "find(id: String)" qui retourneront r√©ciproquement un Array de JSON et un objet JSON correspondant √† la liste de nos utilisateurs et √† un utilisateur en particulier bas√© sur son id. Je ne vais pas utiliser une vraie base de donn√©es mais un truc comme MongoDB irait assez bien dans ce cas. Voici le code :

bc(prettyprint linenums).. package controllers

import play.api._
import play.api.mvc._
import play.api.libs.json._

object Users extends Controller {
  val db = Json.arr(
    Json.obj( "id" -> "1", "name" -> "John" ),
    Json.obj( "id" -> "2", "name" -> "Suzanne" )
  )

  def all() = Action {
    Ok(db)
  }

  def find(id: String) = Action {
    Ok(db.value.filter(v => (v \ "id").as[JsString].value == id).headOption.getOrElse(new JsUndefined("")))
  }
}

p. Si vous ne comprenez pas compl√®tement le code, vous pouvez lire la documentation de PlayFramework sur comment g√©rer du JSON dans les requ√™tes ("http://www.playframework.com/documentation/2.1.0/ScalaJsonRequests":http://www.playframework.com/documentation/2.1.0/ScalaJsonRequests). J'utilise la nouvelle API JSON de Play 2.1 ("http://www.playframework.com/documentation/api/2.1.0/scala/index.html#play.api.libs.json.package":http://www.playframework.com/documentation/api/2.1.0/scala/index.html#play.api.libs.json.package). Nous allons ensuite avoir besoin d'un controller AngularJS du nom de "UserCtrl" qui utilisera le service <code>$resource</code> pour r√©cup√©rer les donn√©es :

bc(prettyprint linenums).. app.controller("UserCtrl", ["$scope", "$routeParams", "$resource", "apiUrl", function($scope, $routeParams, $resource, apiUrl) {
  var Users = $resource(apiUrl + "/users/:id", {id:"@id"});

  if($routeParams.id) {
    $scope.user = Users.get({id: $routeParams.id}, function() {
      if (!$scope.user.id) {
        $scope.msg = "There is no user for id "+$routeParams.id;
      } else {
        $scope.msg = undefined;
      }
    });
  } else {
    $scope.users = Users.query();
  }
}])

p. Pour en apprendre plus sur les possibilit√©s du service $resource d'AngularJS, n'h√©sitez pas √† lire "http://docs.angularjs.org/api/ngResource.$resource":http://docs.angularjs.org/api/ngResource.$resource. A quoi correspond cet "apiUrl" sorti de nul part ? C'est une constante que j'ai d√©fini dans mon application AngularJS :

bc(prettyprint linenums).. var app = angular.module("app", ["ngResource"])
  .constant("apiUrl", "http://localhost:9000\:9000/api")

div(alert alert-info). *Pro tip* Pourquoi est-ce que le port 9000 semble √™tre pr√©sent deux fois ? Parce que si nous avions √©crit <code>http://localhost:9000/api</code>, AngularJS aurait interpr√©t√© cela comme un param√®tre dynamique du nom de "9000" du fait qu'il soit place apr√®s un caract√®re <code>:</code>. Nous avons donc besoin de cette √©trange syntaxe pour indiquer √† AngularJS qui ne s'agit pas d'un param√®tre mais bien d'une valeur fixe dans l'url.

Ensuite, nous allons cr√©er notre resource en √©tendant "apiUrl" par notre routing "/users/:id". Cette fois-ci, ":id" est un vrai param√®tre. Nous pouvons maintenant utiliser les m√©thodes "get" et "query" de la resource, lui passant ou non une valeur pour id, dans le but de r√©cup√©rer notre code JSON et l'assigner dans le <code>$scope</code>. Nous aurons √©galement besoin de deux vues Scala : une pour la liste des utilisateurs et une pour le d√©tail d'un utilisateur.

bc(prettyprint linenums).. @()

@template() {
  <h2>Users</h2>

  <ul>
    <li data-ng-repeat="u in users">
      <a data-ng-href="/users/{{u.id}}">User# {{u.id}}: {{u.name}}</a>
    </li>
  </ul>
}


bc(prettyprint linenums).. @()

@template() {
  <div data-ng-show="msg">
    <h2>{{msg}}</h2>
  </div>

  <div data-ng-hide="msg">
    <h2>User# {{user.id}} {{user.name}}</h2>
  </div>
}

p. Et voil√†. Nous avons maintenant un listing d'utilisateurs et pour chacun un lien vers son d√©tail, tout cela gr√¢ce √† des donn√©es JSON r√©cup√©r√©es depuis une API REST.

div(alert alert-info). *Pro tip* Au passage, comme nos routes Play sont toutes diff√©rentes de nos routes AngularJS, vous pouvez sans soucis les charger directement dans votre navigateur. Comme la redirection d'une route inconnue vers la page principale n'arrive qu'en toute fin de votre fichier de routing, toutes les v√©ritables routes Play seront charg√©es avant cette redirection. Si vous avez la d√©mo qui tourne, affichez "http://localhost:9000/api/users":http://localhost:9000/api/users et "http://localhost:9000/api/users/1":http://localhost:9000/api/users/1 pour voir votre API REST qui fonctionne sans soucis.

h3. Conclusion

J'esp√®re que cet article vous aidera √† d√©marrer votre prochaine g√©niale application en utilisant les incroyables outils que sont AngularJS et PlayFramework. Les prochaines √©tapes, le cas √©ch√©ant, pourraient √™tre d'en apprendre plus sur la nouvelle API JSON de PlayFramework afin d'avoir du JSON typ√© (si je puis dire). Vous pourriez aussi utiliser une vraie base de donn√©es. Un choix comme "MongoDB":http://www.mongodb.org/ serait int√©ressant car cela permettrait de stocker directement le JSON tel quel, et vous pourriez int√©ragir avec en utilisant un driver comme "ReactiveMongo":http://reactivemongo.org/ si vous voulez emprunter le chemin de l'asynchrone complet pour des applications non-bloquantes.

Cela ne d√©pend que de vous !

</div>
</div>