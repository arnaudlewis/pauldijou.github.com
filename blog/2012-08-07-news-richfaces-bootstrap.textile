---
title: "News about RichFaces Bootstrap"
authors: [pauldijou]
layout: post
summary: 0
tags: [en, fr, richfaces, bootstrap, jquery]
---

<ul class="nav nav-tabs">
<li class="active"><a href="#2012-08-07-news-richfaces-bootstrap-en" data-toggle="tab">English version</a></li>
<li><a href="#2012-08-07-news-richfaces-bootstrap-fr" data-toggle="tab">Version Fran√ßaise</a></li>
</ul>

<div class="tab-content">
<div class="tab-pane active" id="2012-08-07-news-richfaces-bootstrap-en">

h3. What's new in RichFaces Bootstrap?

div(alert alert-error). *Red Alert!* The RichFaces Bootstrap project is still under heavy development, tag and attribute names can change at any time and if you find something missing or buggy, there is high chance it's not a bug but just hasn't been done yet (... or it's a real bug). So only use it for fun and prototype purposes.

*Semantic components* are a brand new concept. I need to present it first so I can use it when talking next about the new components. Most of the time, for one JSF tag, you have one and only one HTML renderer, it's a oneToOne relation (according to JSF naming convention). It seems logical: for one component, you should always have (nearly) the same generated HTML code. But with HTML5, the web is becoming more semantic and that's good. Why not have the same with RichFaces? But before we dive into it, what is "semantic"? For a real definition see "Wikipedia":http://en.wikipedia.org/wiki/Semantic_Web but here, we will say it's when a component serves a global purpose like being a header or a footer but shouldn't always render in the same way, instead the rendered result should depend on the context (like a table header isn't the same as a column header).

With RichFaces, a semantic component is a component *with no renderer*! Yeah yeah, if you use a semantic component on its own, it will throw an exception because it doesn't know how to render itself. The concept is that a semantic component will ask its parent in the JSF tree: "Hey dad, do you know how I can render myself?", if it knows, the parent will provide the correct renderer to the semantic component which will render it, otherwise, the semantic component will ask one level higher the same question, and so on until the root element. If no one answers yes to the question, it will throw an exception. That means we also have components that accept semantic components in order to provide them the correct renderer.

Let's take a concrete example. The *modal* component in RichFaces Bootstrap can support 3 semantic components: a header, a body and a footer. You can see that by looking at which interfaces the <code>AbstractModal</code> implements (see "GitHub":https://github.com/richfaces/sandbox/blob/develop/bootstrap/ui/src/main/java/org/richfaces/bootstrap/component/AbstractModal.java#L49). All interfaces with the syntax <code>Render{1}Capable</code> are components that support the semantic component <code>{1}</code>, so here, it's *headerFacet*, *bodyFacet* and *footerFacet*. And if you look at the rest of the code of the <code>AbstractModal</code>, you will see methods with the syntax <code>public String get{1}RendererType()</code> which are the methods giving the right renderer to use by semantic components. Inside a *modal*, the *headerFacet* component will render as a <code>div class="modal-header"</code> according to "the renderer provided":https://github.com/richfaces/sandbox/blob/develop/bootstrap/ui/src/main/templates/org/richfaces/bootstrap/modalHeaderFacet.template.xml by the *modal*. But inside another component, it could have been totally different HTML code.

div(alert alert-info). *Pro tip* If you take a more accurate look to all current semantic components, you will see that they all follow the same syntax: first their purpose (like *header* or *footer*) and then a generic *Facet* suffix. That give us the full list of semantic components: headerFacet, bodyFacet, footerFacet, menuFacet and positionFacet. Why using a suffix? Because we want to keep the no-suffix name for the real HTML tag. The RichFaces *header* tag will always generate the HTML *header* tag like a classic JSF tag (the oneToOne relation) but the *headerFacet* tag is a semantic component so it can generate anything depending of the context. Also, it makes it easier to see if a RichFaces component is a semantic one or not by just looking at its name.

div(alert). *Warning* Even if the suffix is *Facet* keep in mind that semantic components *are not facets*, they don't have the same limitations: they have attributes, you can use the same semantic component several time inside the same parent, a semantic component doesn't have to be a direct child of a component supporting it and a semantic component can have several children.

Now, let's dive into the new components. "input":http://bootstrap-richfaces.rhcloud.com/component/input/ tag is a basic input with all Bootstrap features like prepend and append and several new attributes in order to support new HTML features. By the way, this *input* centralizes and supports all HTML5 input types, you will no longer need one JSF component for each type, just use the <code>type</code> attribute (default is "text" of course).

"modal":http://bootstrap-richfaces.rhcloud.com/component/modal/ is like <code>rich:modalPanel</code> or <code>rich:popupPanel</code>, it will display a popup layout on top of your page, potentially covering your page with a dark layer to block any action outside of the modal. The default usage of the modal has a header, specified by using <code>header</code> attribute or <code>header</code> facet, a footer specified with <code>footer</code> facet and a <code>body</code> which will be the code inside the modal component. Concretely, what's happening is that each part, header - body - footer, will be wrapped inside a <code>div class="modal-xxx"</code> where "xxx" is the name of the section in order to align with the Bootstrap syntax. Using footer as a facet might be limiting because you cannot have *a form inside the modal* wrapping both body and footer because footer, as a facet, will always be outside. The default usage should be *the modal inside the form* since you will probably not need several forms inside a modal most of the time.

What if that isn't enough? What if you do want the form inside and not outside? Even if this behavior should be enough in most of use-cases, you can still fully customize your modal the way you want! The moment you use one of the following semantic components, headerFacet - bodyFacet - footerFacet, it considers you are doing a custom modal and it will not generate the <code>div class="modal-xxx"</code> anymore. I'm talking about the modal itself. Because the semantic components will generate the corresponding <code>div</code>. However using real components and not facets will allow you to put both bodyFacet and footerFacet inside a form for example.

"tooltip":http://bootstrap-richfaces.rhcloud.com/component/tooltip/ and "popover":http://bootstrap-richfaces.rhcloud.com/component/popover/ are two new ways to display bonus info when the mouse moves over particular content. The first one is for small texts and labels only, the second one can support custom content and a title. Right now, content can only be text but we are planning to improve this.

div(alert alert-info). *Pro tip* Even if *popover* content only supports text, you can still put some light HTML in it. You just need to escape chevrons with <code>&lt;</code> and <code>&gt;</code>.

Finally, "orderingList":http://bootstrap-richfaces.rhcloud.com/component/orderingList/ is the new RichFaces ordering list to allow you to re-arrange the order of some items. It already supports single drag-and-drop, multiple selection and "table" layout. Next features will be multiple drag-and-drop, maybe keyboard selection using SHIFT (CTRL is already supported). Thanks to Brian work, it is the first component mixing the power of the jQuery UI widget factory with Bootstrap design. If we can do it once, we can do it for lots of other widgets!

New EL functions are also there. "jQuery":https://github.com/richfaces/components/blob/develop/misc/ui/src/main/java/org/richfaces/function/RichFunction.java#L156 and "jQuerySelector":https://github.com/richfaces/components/blob/develop/misc/ui/src/main/java/org/richfaces/function/RichFunction.java#L126 are part of RichFaces Core but have been created to help RichFaces Bootstrap. They will allow you to retrieve a jQuery object or the jQuery selector from a server-side JSF id.

Next are more "specific Bootstrap EL functions":http://bootstrap-richfaces.rhcloud.com/component/el/. If you have take a look at Bootstrap JavaScript API, you might have noticed that lots of JavaScript components have a set of functions with the following syntax: <code>$(sel).compName('singleParameter');</code>, like for example: <code>$('#myModal').modal('show');</code> for a *modal*. The first approach to use it in JSF component was to use the previous *jQuery* function like: <code>onclick="\#{rich:jQuery( 'myModal' )}.modal('show')"</code>. It works fine but obviously, that wasn't enough for Lukas since he built a different approach from scratch.

The new concept is that the <code>compName</code> part of the call is nearly useless if you can retrieve it from the component returned from the jQuery call. In the previous example, if you know that <code>\#{rich:jQuery('myModal')}</code> is actually a *modal* component, then you also know that you will have to call the *modal* function, only remains with importance the *singleParameter*. So here is the new syntax: <code>\#{b:singleParameter(sel)}</code>. The previous example becomes: <code>onclick="\#{b:show('myModal')}"</code>. Much more concise and readable, isn't it? Right now, RichFaces Bootstrap supports *show*, *hide* and *toggle* functions but others will follow soon.

div(alert alert-info). *Pro tip* Want to know how the EL function retrieves the name of the component? Easy. When the selector will be used to find the JSF component, it will find a *UIComponent* (like a *UIModal*) which, according to RichFaces CDK design, will extend an *AbstractComponent* (like "AbstractModal":https://github.com/richfaces/sandbox/blob/develop/bootstrap/ui/src/main/java/org/richfaces/bootstrap/component/AbstractModal.java). And if the *AbstractComponent* supports Bootstrap EL functions, it will be annotated with <code>@BootstrapJSPlugin</code> (like at "line 43 of AbstractModal":https://github.com/richfaces/sandbox/blob/develop/bootstrap/ui/src/main/java/org/richfaces/bootstrap/component/AbstractModal.java#L43) and it's the <code>name</code> attribute of that annotation that will give us the <code>componentName</code>. As I told you, really easy!

*LESS support* is no longer a dream (for those who doesn't know LESS, it's a more powerful way to write CSS, see the "project website":http://lesscss.org/ for more infos). Thanks to Lukas' awesome work, a first prototype of that feature is already working. You can "read his post":http://rik-ansikter.blogspot.fr/2012/08/jsf-meets-skinning-awesomeness-of-less.html to know more about that. There is still work to do but it's an incredible starting point.

h3. What's coming?

Want more? Great, because we have tons of other plans to improve RichFaces!

*New build design* is currently under "discussion on RichFaces wiki":https://community.jboss.org/wiki/RichFaces43BuildRedesign so be sure to take a look and give feedback if you care about the future of RichFaces.

*Theming all current components* from RichFaces Core with Bootstrap design is planned so you can use both projects at the same time.

The orderingList is just a beginning. *More jQuery UI widget factory based components* are incoming. Feel free to comment "here":https://community.jboss.org/thread/200343 to propose the ones you would like to see supported in RichFaces Bootstrap.

</div>
<div class="tab-pane" id="2012-08-07-news-richfaces-bootstrap-fr">

h3. Quoi de neuf au sein de RichFaces Bootstrap ?

div(alert alert-error). *Alerte rouge !* Le projet RichFaces Bootstrap est encore en pleine phase de d√©veloppement. Les noms des balises et de leurs attributs peuvent changer √† tout moment et si vous trouvez un bug ou que quelque chose manque, il y a de fortes changes que cela n'ait juste pas √©t√© encore fait (... ou alors c'est vraiment un bug). N'utilisez ce projet qu'√† des fins de prototypage ou pour le plaisir.

*Les composants s√©mantiques* repr√©sentent un tout nouveau concept. Je me dois de les pr√©senter en premier car j'en aurais ensuite besoin quand je vous parlerai des nouveaux composants. La plupart du temps, pour un composant JSF, vous avez un et un seul code HTML g√©n√©r√©, il s'agit d'une relation oneToOne (si l'on devait utiliser le vocabulaire de la norme JPA). C'est tout √† fait logique : pour un composant, vous devriez toujours aboutir au m√™me code HTML g√©n√©r√© (√† quelques d√©tails de configuration pr√™t). Mais avec HTML5, le web devient un peu plus semantique et c'est tant mieux. Alors pourquoi ne pas avoir la m√™me chose dans RichFaces ? Mais avant d'aller plus loin, qu'est-ce qu'√™tre "s√©mantique" ? Pour une v√©ritable d√©finition, voyez "Wikip√©dia":http://fr.wikipedia.org/wiki/Web_s%C3%A9mantique (la "version anglaise":http://en.wikipedia.org/wiki/Semantic_Web est peut √™tre pr√©f√©rable cela dit), mais dans notre cas, nous allons dire qu'il s'agit de composants qui ont une fonctionnalit√© globale, comme √™tre un "header" ou un "footer", et ne devraient pas toujours g√©n√©rer le m√™me code HTML mais au contraire d√©pendre leur contexte (tout comme un "header" de table n'est pas pareil qu'un "header" de colonne).

Dans RichFaces, un composant s√©mantique est un composant *qui n'a pas de renderer*! Oui oui, si vous utilisez un composant s√©mantique en solitaire, il vous lancera une exception √† la figure car il ne sait pas quoi g√©n√©rer comme code HTML par lui m√™me. Le concept est qu'un composant s√©mantique doit demander √† son composant parent dans l'arbre JSF la question suivante : "Hey papa, est-ce que tu sais quel code HTML je dois g√©n√©rer ?" (ou bien "Hey papa, est-ce que tu sais quel renderer je dois utiliser ?"). Si le p√®re connait la r√©ponse, il devra fournir au composant s√©mantique le bon renderer, sinon, le composant s√©mantique devra reposer la question un niveau plus haut dans l'arbre JSF et ainsi de suite jusqu'√† l'√©l√©ment racine. Si personne n'a √©t√© capable de lui fournir une bonne r√©ponse, et donc un renderer, il lancera une exception. Cela signifie bien sur qu'il y a d√©sormais des composants supportant les composants s√©mantiques.

Assez de th√©orie, prenons un exemple concret ! Le composant *modal* dans RichFaces Bootstrap supporte 3 composants s√©mantiques : un header, un body et un footer. On peut voir cela en regardant quelles interfaces sont impl√©ment√©es par <code>AbstractModal</code> (regardez "le code sur GitHub":https://github.com/richfaces/sandbox/blob/develop/bootstrap/ui/src/main/java/org/richfaces/bootstrap/component/AbstractModal.java#L49). Toutes les interfaces ayant une syntaxe de la forme <code>Render{1}Capable</code> indiquent que notre composant supporte les composants s√©mantiques ayant pour nom <code>{1}</code>, dans notre cas, *headerFacet*, *bodyFacet* et *footerFacet*. Et si vous regardez plus en d√©tail le code de <code>AbstractModal</code>, vous verrez des m√©thodes ayant pour syntaxe <code>public String get{1}RendererType()</code>. Il s'agit des m√©thodes qui auront pour t√¢che de fournir le bon renderer aux composants s√©mantiques fils. Par exemple, dans le cadre du *modal*, le composant s√©mantique *headerFacet* g√©n√®rera un <code>div class"=modal-header"</code> si l'on en croit "le renderer fournit":https://github.com/richfaces/sandbox/blob/develop/bootstrap/ui/src/main/templates/org/richfaces/bootstrap/modalHeaderFacet.template.xml par le *modal*. Mais √† l'int√©rieur d'un autre composant, cela aurait pu √™tre un code HTML totalement diff√©rent.

div(alert alert-info). *Pro tip* Si vous prenez le temps de regarder en d√©tail tous les composants s√©mantiques, vous remarquerez qu'ils suivent tous la m√™me syntaxe : en premier leur fonction (comme *header* ou *footer*) et ensuite un suffixe commun *Facet*. Cela nous donne la liste compl√®te des actuels composants s√©mantiques : headerFacet, bodyFacet, footerFacet, menuFacet et footerFacet. Pourquoi utiliser un suffixe ? Tout d'abord parce que nous souhaitons conserver le nom sans suffixe pour la v√©ritable balise HTML correspondante. Le composant RichFaces *header* devra toujours g√©n√©rer une balise HTML *header* comme un composant JSF classique (la fameuse relation oneToOne) tandis que le composant *headerFacet*, √©tant de nature s√©mantique, peut g√©n√©rer n'importe quel code HTML d√©pendant de son contexte d'utilisation. Ensuite parce que cela rend la vie plus facile pour savoir, rien qu'√† son nom, si un composant RichFaces est s√©mantique ou non.

div(alert). *Attention* M√™me si le suffixe utilis√© est *Facet*, gardez bien √† l'esprit que les componsants s√©mantiques *ne sont pas des facets* m√™me s'ils y ressemblent fortement dans l'id√©e. Cons√©quence directe : ils n'ont pas les m√™mes limitations. Les composants s√©mantiques ont des attributs, peuvent avoir plusieurs fils et ne doivent pas forc√©ment √™tre un fils direct du composant parent les supportant. Vous pouvez √©galement utiliser plusieurs fois le m√™me composant s√©mantique dans un m√™me composant parent.

Passons maintenant aux nouveaux composants. Le composant "input":http://bootstrap-richfaces.rhcloud.com/component/input/ est un input classique mais boost√© avec les fonctionnalit√©s de Bootstrap comme prepend et append, ainsi que de nouveaux attributs pour supporter les nouvelles fonctionnalit√©s HTML. Au passage, ce nouvel *input* centralise et supporte tous les types d'input en HTML5. Vous n'aurez donc plus besoin d'avoir un composant JSF par type d'input, il vous suffira d'utiliser l'attribute <code>type</code> (la valeur par d√©faut √©tant "text" bien entendu).

"modal":http://bootstrap-richfaces.rhcloud.com/component/modal/ est dans la m√™me veine que <code>rich:modalPanel</code> ou <code>rich:popupPanel</code>. Il aura pour effet de faire apparaitre une fen√™tre d'alerte au dessus de votre page, couvrant potentiellement celle-ci d'un filtre sombre pour emp√™cher toute action en dehors du modal. L'usage par d√©faut est d'avoir un header, sp√©cifi√© en utilisant l'attribut <code>header</code> ou le facet <code>header</code>, un footer, via le facet <code>footer</code>, et un <code>body</code> qui correspondra au contenu de la balise modal. Concr√®tement, ce qui se passe est que chaque partie, header - body - footer, va g√©n√©rer un <code>div class="modal-xxx"</code>, o√π "xxx" correspond √† ladite partie, autour de son contenu afin de respecter la syntaxe de Bootstrap. Avoir le footer dans un facet peut √™tre limitant car vous ne pouvez pas avoir *un formulaire √† l'int√©rieur du modal* qui encapuselerait √† la fois le body et le footer car le footer, en tant que facet, se retrouvera toujours √† l'ext√©rieur. L'usage recommand√© est d'avoir *le modal entier √† l'int√©rieur du formulaire* compte tenu du fait que vous n'aurez surement pas besoin d'avoir plusieurs formulaires dans un m√™me modal la plupart du temps.

Mais que se passe-t-il si cela ne vous convient pas ? Si vous voulez vraiment le formulaire √† l'int√©rieur et non √† l'ex√©rieur ? M√™me si le comportement par d√©faut d√©crit juste avant devrait √™tre suffisant dans la grande majorit√© des cas, il est parfaitement compr√©hensible que dans certains cas, vous souhaitiez configurer votre modal de A √† Z. Pour ce faire, il vous suffit d'utiliser un des composants s√©mantiques suivant dans votre modal : headerFacet, bodyFacet, footerFacet. A partir du moment o√π l'un d'entre eux est d√©tect√©, le modal est consid√©r√© comme customis√© et il ne g√©n√®re plus de <code>div class="modal-xxx</code> par lui m√™me. Je parle bien du modal en personne, les composants s√©mantiques, eux, g√©n√®reront les <code>div</code> correspondant √† leur fonction. Cela vous permettra, par exemple, d'avoir vos bodyFacet et footerFacet √† l'int√©rieur du m√™me formulaire lui m√™me √† l'int√©rieur du modal.

"tooltip":http://bootstrap-richfaces.rhcloud.com/component/tooltip/ et "popover":http://bootstrap-richfaces.rhcloud.com/component/popover/ sont deux nouveaux moyens d'afficher des informations suppl√©mentaires lorsque la souris passe au dessus d'un contenu en particulier. Le premier est plut√¥t orient√© vers de courts textes ou des libell√©s tandis que le second peut poss√©der un contenu plus cons√©quent et m√™me un titre. Pour le moment, le contenu en question ne peut √™tre que du texte brut mais il est pr√©vu d'am√©liorer cela.

div(alert alert-info). *Pro tip* M√™me si *popover* ne supporte que du contenu textuel pour le moment, vous pouvez quand m√™me utiliser un peu de HTML dedans. Il vous faudra juste √©charper les chevrons en les rempla√ßant par <code>&lt;</code> et <code>&gt;</code>.

Enfin, "orderingList":http://bootstrap-richfaces.rhcloud.com/component/orderingList/ est la nouvelle version de RichFaces pour son composant oderingList et vous permet de r√©organiser l'ordre des √©l√©ments d'une liste. Il supporte d'ores et d√©j√† le drag-and-drop (glisser-d√©poser) d'un √©l√©ment individuel, la s√©lection multiple et un design en forme de "table". Les fonctionnalit√©s √† venir sont le drap-and-drop de plusieurs √©l√©ments √† la fois et peut √™tre la s√©lection en utilisant la touche SHIFT du clavier (CTRL est d√©j√† support√©). Gr√¢ce au travail de Brian, il s'agit du tout premier composant utilisant √† la fois la puissance de jQuery UI widget factory avec un design Bootstrap. Si nous pouvons le faire une fois, alors nous pouvons √©galement le faire pour bien d'autres widgets jQuery.

De nouvelles fonctions EL sont √©galement de la partie. "jQuery":https://github.com/richfaces/components/blob/develop/misc/ui/src/main/java/org/richfaces/function/RichFunction.java#L156 et "jQuerySelector":https://github.com/richfaces/components/blob/develop/misc/ui/src/main/java/org/richfaces/function/RichFunction.java#L126 se trouvent directement dans RichFaces Core mais ont √©t√© cr√©√©es avant tout dans l'optique d'√™tre utilis√©es dans RichFaces Bootstrap. Elles vous permettent de r√©cup√©rer un objet jQuery ou un s√©lecteur jQuery √† partir de l'id JSF c√¥t√© serveur.

Ensuite viennent des "fonctions EL sp√©cifiques √† Bootstrap":http://bootstrap-richfaces.rhcloud.com/component/el/. Si vous regardez l'API JavaScript de Bootstrap, vous noterez que nombre de composants JavaScript poss√®dent une liste de fonctions avec la syntaxe suivante : <code>$(sel).nomDuComposant('paramUnique');</code>, comme par exemple : <code>$('#monModal').modal('show');</code> pour un *modal*. La premi√®re approche pour les utiliser dans une page JSF est de de servir de la fonction *jQuery* vue pr√©c√©demment de la mani√®re suivante : <code>onclick="\#{rich:jQuery( 'monModal' )}.modal('show')"</code>. Cela fonctionne √† merveille mais ce n'√©tait visiblement pas suffisant pour Lukas qui s'est offert le luxe de coder depuis z√©ro une autre approche.

Le nouveau concept vient du fait que la partie <code>nomComp</code> est inutile si vous pouvez r√©cup√©rer ledit nom depuis le composant retourn√© par l'appel √† jQuery. Dans l'exemple pr√©c√©dent, si l'on sait que <code>\#{rich:jQuery('monModal')}</code> va retourner un *modal* alors on sait √©galement que c'est la fonction *modal* qu'il faudra appeler, si bien que la seule inconnue restante est le *paramUnique*. Voici donc la nouvelle syntaxe : <code>\#{b:paramUnique(sel)}</code>. L'exemple pr√©c√©dent devient : <code>onclick="\#{b:show('monModal')}"</code>. Bien moins verbeux et bien plus lisible n'est-ce pas ? A l'heure actuelle, RichFaces Bootstrap poss√®de les fonctions *show*, *hide* et *toggle* mais d'autres suivront bient√¥t.

div(alert alert-info). *Pro tip* Envie de savoir comment la fonction EL r√©cup√®re le nom du composant ? Facile. Quand le s√©lecteur est utilis√© pour r√©cup√©rer le composant JSF, il va retourner un *UIComponent* (par exemple un *UIModal*) qui, en accord avec la syntaxe du CDK RichFaces, devra √©tendre un *AbstractComponent* (comme "AbstractModal":https://github.com/richfaces/sandbox/blob/develop/bootstrap/ui/src/main/java/org/richfaces/bootstrap/component/AbstractModal.java). Et si cet *AbstractComponent* supporte les fonctions EL sp√©cifiques √† Bootstrap, alors il sera annot√© de <code>@BootstrapJSPlugin</code> (comme on peut le voir √† "la ligne 43 de AbstractModal":https://github.com/richfaces/sandbox/blob/develop/bootstrap/ui/src/main/java/org/richfaces/bootstrap/component/AbstractModal.java#L43) et c'est l'attribute <code>name</code> de l'annotation qui nous fournit le <code>nomDuComposant</code>. Comme je vous l'avais dit, super facile !

*Le support de LESS* n'est plus un r√™ve mais d√©sormais une r√©alit√© (pour ceux qui ne connaissent pas LESS, il s'agit d'une syntaxe permettant d'√©crire du CSS de mani√®re bien plus puissante et √©l√©gante, je vous encourage √† consulter le "site du projet":http://lesscss.org/ pour de plus amples informations). Gr√¢ce au travail incroyable de Lukas, un premier prototype est d√©j√† fonctionnel. N'h√©sitez pas √† "lire son article":http://rik-ansikter.blogspot.fr/2012/08/jsf-meets-skinning-awesomeness-of-less.html √† ce sujet pour en savoir plus (anglais uniquement). Il y a encore du travail √† faire, mais il s'agit un bon point de d√©part.

h3. Qu'avons nous en approche ?

Vous en voulez encore ? Tant mieux car nous avons de nombreuses id√©es pour am√©liorer RichFaces !

*Un nouveau mod√®le de build* est en cours de "discussion sur le wiki RichFaces":https://community.jboss.org/wiki/RichFaces43BuildRedesign. Je vous encourage vivement √† prendre le temps de le lire (en anglais uniquement) et de donner votre avis si vous vous sentez concern√© par l'avenir de RichFaces.

Il est pr√©vu de fournir *un nouveau design √† tous les composants* de RichFaces Core √† partir du design de Bootstrap pour que vous puissez utiliser les deux projets en m√™me temps.

Le composant orderingList n'est que le commencement. *D'autres composants bas√©s sur jQuery UI widget factory* sont en approche. N'h√©sitez pas √† "poster ici":https://community.jboss.org/thread/200343 pour proposer des widgets que vous aimeriez voir dans RichFaces Bootstrap.

</div>
</div>